diff '--color=auto' -ruN slock/config.def.h slock-1.4/config.def.h
--- slock/config.def.h	2016-11-19 19:31:23.000000000 -0500
+++ slock-1.4/config.def.h	2022-09-09 22:03:12.379170633 -0400
@@ -1,6 +1,6 @@
 /* user and group to drop privileges to */
-static const char *user  = "nobody";
-static const char *group = "nogroup";
+static const char *user  = "daisys";
+static const char *group = "users";
 
 static const char *colorname[NUMCOLS] = {
 	[INIT] =   "black",     /* after initialization */
@@ -10,3 +10,18 @@
 
 /* treat a cleared input like a wrong password (color) */
 static const int failonclear = 1;
+
+/* default message */
+static const char * message = "Enter Password To Unlock: Hello world";
+
+/* text color */
+static const char * text_color = "#ffffff";
+
+/* text size (must be a valid size) */
+static const char * font_name = "Great Vibes";
+
+/* Background image path, should be available to the user above */
+static const char* background_image = "/home/daisys/backgrounds/someonesfanart.jpg";
+
+/* time in seconds before the monitor shuts down */
+static const int monitortime = 30;
diff '--color=auto' -ruN slock/config.h slock-1.4/config.h
--- slock/config.h	1969-12-31 19:00:00.000000000 -0500
+++ slock-1.4/config.h	2022-09-09 21:13:28.108660229 -0400
@@ -0,0 +1,27 @@
+/* user and group to drop privileges to */
+static const char *user  = "nobody";
+static const char *group = "nobody";
+
+static const char *colorname[NUMCOLS] = {
+	[INIT] =   "black",     /* after initialization */
+	[INPUT] =  "#005577",   /* during input */
+	[FAILED] = "#CC3333",   /* wrong password */
+};
+
+/* treat a cleared input like a wrong password (color) */
+static const int failonclear = 1;
+
+/* default message */
+static const char * message = "Enter Password To Unlock";
+
+/* text color */
+static const char * text_color = "#ffffff";
+
+/* text size (must be a valid size) */
+static const char * font_name = "6x10";
+
+/* Background image path, should be available to the user above */
+static const char* background_image = "/home/daisys/backgrounds/someonesfanart.jpg";
+
+/* time in seconds before the monitor shuts down */
+static const int monitortime = 30;
diff '--color=auto' -ruN slock/config.mk slock-1.4/config.mk
--- slock/config.mk	2016-11-19 19:31:23.000000000 -0500
+++ slock-1.4/config.mk	2022-09-09 20:59:57.942462771 -0400
@@ -12,7 +12,7 @@
 
 # includes and libs
 INCS = -I. -I/usr/include -I${X11INC}
-LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lXext -lXrandr
+LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lXext -lXrandr -lXinerama -lImlib2
 
 # flags
 CPPFLAGS = -DVERSION=\"${VERSION}\" -D_DEFAULT_SOURCE -DHAVE_SHADOW_H
diff '--color=auto' -ruN slock/slock.1 slock-1.4/slock.1
--- slock/slock.1	2016-11-19 19:31:23.000000000 -0500
+++ slock-1.4/slock.1	2022-09-09 20:58:51.856086951 -0400
@@ -6,6 +6,8 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl v
+.Op Fl f
+.Op Fl m Ar message
 .Op Ar cmd Op Ar arg ...
 .Sh DESCRIPTION
 .Nm
@@ -16,6 +18,11 @@
 .Bl -tag -width Ds
 .It Fl v
 Print version information to stdout and exit.
+.It Fl f
+List all valid X fonts and exit.
+.It Fl m Ar message
+Overrides default slock lock message.
+.TP
 .El
 .Sh SECURITY CONSIDERATIONS
 To make sure a locked screen can not be bypassed by switching VTs
diff '--color=auto' -ruN slock/slock.c slock-1.4/slock.c
--- slock/slock.c	2016-11-19 19:31:23.000000000 -0500
+++ slock-1.4/slock.c	2022-09-09 21:47:18.875687179 -0400
@@ -15,15 +15,70 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <X11/extensions/Xrandr.h>
+#include <X11/extensions/Xinerama.h>
+#include <X11/extensions/dpms.h>
 #include <X11/keysym.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
+#include <Imlib2.h>
 
 #include "arg.h"
 #include "util.h"
 
+void feh_print_load_error(char *file, Imlib_Load_Error err)
+{
+	if (err == IMLIB_LOAD_ERROR_OUT_OF_FILE_DESCRIPTORS)
+		printf("%s - Out of file descriptors while loading", file);
+		switch (err) {
+		case IMLIB_LOAD_ERROR_FILE_DOES_NOT_EXIST:
+			printf("%s - File does not exist", file);
+			break;
+		case IMLIB_LOAD_ERROR_FILE_IS_DIRECTORY:
+			printf("%s - Directory specified for image filename", file);
+			break;
+		case IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_READ:
+			printf("%s - No read access", file);
+			break;
+		case IMLIB_LOAD_ERROR_UNKNOWN:
+		case IMLIB_LOAD_ERROR_NO_LOADER_FOR_FILE_FORMAT:
+			printf("%s - No Imlib2 loader for that file format", file);
+			break;
+		case IMLIB_LOAD_ERROR_PATH_TOO_LONG:
+			printf("%s - Path specified is too long", file);
+			break;
+		case IMLIB_LOAD_ERROR_PATH_COMPONENT_NON_EXISTANT:
+			printf("%s - Path component does not exist", file);
+			break;
+		case IMLIB_LOAD_ERROR_PATH_COMPONENT_NOT_DIRECTORY:
+			printf("%s - Path component is not a directory", file);
+			break;
+		case IMLIB_LOAD_ERROR_PATH_POINTS_OUTSIDE_ADDRESS_SPACE:
+			printf("%s - Path points outside address space", file);
+			break;
+		case IMLIB_LOAD_ERROR_TOO_MANY_SYMBOLIC_LINKS:
+			printf("%s - Too many levels of symbolic links", file);
+			break;
+		case IMLIB_LOAD_ERROR_OUT_OF_MEMORY:
+			printf("While loading %s - Out of memory", file);
+			break;
+		case IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_WRITE:
+			printf("%s - Cannot write to directory", file);
+			break;
+		case IMLIB_LOAD_ERROR_OUT_OF_DISK_SPACE:
+			printf("%s - Cannot write - out of disk space", file);
+			break;
+		default:
+			printf("While loading %s - Unknown error (%d)",
+					file, err);
+			break;
+		}
+}
+
 char *argv0;
 
+/* global count to prevent repeated error messages */
+int count_error = 0;
+
 enum {
 	INIT,
 	INPUT,
@@ -35,6 +90,7 @@
 	int screen;
 	Window root, win;
 	Pixmap pmap;
+	Pixmap bgmap;
 	unsigned long colors[NUMCOLS];
 };
 
@@ -46,6 +102,8 @@
 
 #include "config.h"
 
+Imlib_Image image;
+
 static void
 die(const char *errstr, ...)
 {
@@ -83,6 +141,132 @@
 }
 #endif
 
+static int
+readescapedint(const char *str, int *i) {
+	int n = 0;
+	if (str[*i])
+		++*i;
+	while(str[*i] && str[*i] != ';' && str[*i] != 'm') {
+		n = 10 * n + str[*i] - '0';
+		++*i;
+	}
+	return n;
+}
+
+static void
+writemessage(Display *dpy, Window win, int screen)
+{
+	int len, line_len, width, height, s_width, s_height, i, k, tab_size, r, g, b, escaped_int, curr_line_len;
+	XGCValues gr_values;
+	XFontStruct *fontinfo;
+	XColor color, dummy;
+	XineramaScreenInfo *xsi;
+	GC gc;
+	fontinfo = XLoadQueryFont(dpy, font_name);
+
+	if (fontinfo == NULL) {
+		if (count_error == 0) {
+			fprintf(stderr, "slock: Unable to load font \"%s\"\n", font_name);
+			fprintf(stderr, "slock: Try listing fonts with 'slock -f'\n");
+			count_error++;
+		}
+		return;
+	}
+
+	tab_size = 8 * XTextWidth(fontinfo, " ", 1);
+
+	XAllocNamedColor(dpy, DefaultColormap(dpy, screen),
+		 text_color, &color, &dummy);
+
+	gr_values.font = fontinfo->fid;
+	gr_values.foreground = color.pixel;
+	gc=XCreateGC(dpy,win,GCFont+GCForeground, &gr_values);
+
+	/*  To prevent "Uninitialized" warnings. */
+	xsi = NULL;
+
+	/*
+	 * Start formatting and drawing text
+	 */
+
+	len = strlen(message);
+
+	/* Max max line length (cut at '\n') */
+	line_len = curr_line_len = 0;
+	k = 0;
+	for (i = 0; i < len; i++) {
+		if (message[i] == '\n') {
+			curr_line_len = 0;
+			k++;
+		} else if (message[i] == 0x1b) {
+			while (i < len && message[i] != 'm') {
+				i++;
+			}
+			if (i == len)
+				die("slock: unclosed escape sequence\n");
+		} else {
+			curr_line_len += XTextWidth(fontinfo, message + i, 1);
+			if (curr_line_len > line_len)
+				line_len = curr_line_len;
+		}
+	}
+	/* If there is only one line */
+	if (line_len == 0)
+		line_len = len;
+
+	if (XineramaIsActive(dpy)) {
+		xsi = XineramaQueryScreens(dpy, &i);
+		s_width = xsi[0].width;
+		s_height = xsi[0].height;
+	} else {
+		s_width = DisplayWidth(dpy, screen);
+		s_height = DisplayHeight(dpy, screen);
+	}
+	height = s_height*3/7 - (k*20)/3;
+	width  = (s_width - line_len)/2;
+
+	line_len = 0;
+	/* print the text while parsing 24 bit color ANSI escape codes*/
+	for (i = k = 0; i < len; i++) {
+		switch (message[i]) {
+			case '\n':
+				line_len = 0;
+				while (message[i + 1] == '\t') {
+					line_len += tab_size;
+					i++;
+				}
+				k++;
+				break;
+			case 0x1b:
+				i++;
+				if (message[i] == '[') {
+					escaped_int = readescapedint(message, &i);
+					if (escaped_int == 39)
+						continue;
+					if (escaped_int != 38)
+						die("slock: unknown escape sequence%d\n", escaped_int);
+					if (readescapedint(message, &i) != 2)
+						die("slock: only 24 bit color supported\n");
+					r = readescapedint(message, &i) & 0xff;
+					g = readescapedint(message, &i) & 0xff;
+					b = readescapedint(message, &i) & 0xff;
+					XSetForeground(dpy, gc, r << 16 | g << 8 | b);
+				} else
+					die("slock: unknown escape sequence\n");
+				break;
+			default:
+				XDrawString(dpy, win, gc, width + line_len, height + 20 * k, message + i, 1);
+				line_len += XTextWidth(fontinfo, message + i, 1);
+		}
+	}
+
+	/* xsi should not be NULL anyway if Xinerama is active, but to be safe */
+	if (XineramaIsActive(dpy) && xsi != NULL)
+			XFree(xsi);
+}
+
+
+
 static const char *
 gethash(void)
 {
@@ -190,10 +374,12 @@
 			color = len ? INPUT : ((failure || failonclear) ? FAILED : INIT);
 			if (running && oldc != color) {
 				for (screen = 0; screen < nscreens; screen++) {
-					XSetWindowBackground(dpy,
-					                     locks[screen]->win,
-					                     locks[screen]->colors[color]);
+                                        if (locks[screen]->bgmap)
+                                                XSetWindowBackgroundPixmap(dpy, locks[screen]->win, locks[screen]->bgmap);
+                                        else
+                                                XSetWindowBackground(dpy, locks[screen]->win, locks[screen]->colors[0]);
 					XClearWindow(dpy, locks[screen]->win);
+					writemessage(dpy, locks[screen]->win, screen);
 				}
 				oldc = color;
 			}
@@ -227,6 +413,17 @@
 	lock->screen = screen;
 	lock->root = RootWindow(dpy, lock->screen);
 
+        if(image)
+        {
+            lock->bgmap = XCreatePixmap(dpy, lock->root, DisplayWidth(dpy, lock->screen), DisplayHeight(dpy, lock->screen), DefaultDepth(dpy, lock->screen));
+            imlib_context_set_display(dpy);
+            imlib_context_set_visual(DefaultVisual(dpy, lock->screen));
+            imlib_context_set_colormap(DefaultColormap(dpy, lock->screen));
+            imlib_context_set_drawable(lock->bgmap);
+            imlib_render_image_on_drawable(0, 0);
+            imlib_free_image();
+        }
+
 	for (i = 0; i < NUMCOLS; i++) {
 		XAllocNamedColor(dpy, DefaultColormap(dpy, lock->screen),
 		                 colorname[i], &color, &dummy);
@@ -243,6 +440,8 @@
 	                          CopyFromParent,
 	                          DefaultVisual(dpy, lock->screen),
 	                          CWOverrideRedirect | CWBackPixel, &wa);
+        if(lock->bgmap)
+          XSetWindowBackgroundPixmap(dpy, lock->win, lock->bgmap);
 	lock->pmap = XCreateBitmapFromData(dpy, lock->win, curs, 8, 8);
 	invisible = XCreatePixmapCursor(dpy, lock->pmap, lock->pmap,
 	                                &color, &color, 0, 0);
@@ -292,7 +491,7 @@
 static void
 usage(void)
 {
-	die("usage: slock [-v] [cmd [arg ...]]\n");
+	die("usage: slock [-v] [-f] [-m message] [cmd [arg ...]]\n");
 }
 
 int
@@ -305,12 +504,26 @@
 	gid_t dgid;
 	const char *hash;
 	Display *dpy;
-	int s, nlocks, nscreens;
+	int i, s, nlocks, nscreens;
+	CARD16 standby, suspend, off;
+	int count_fonts;
+	char **font_names;
 
 	ARGBEGIN {
 	case 'v':
 		fprintf(stderr, "slock-"VERSION"\n");
 		return 0;
+	case 'm':
+		message = EARGF(usage());
+		break;
+	case 'f':
+		if (!(dpy = XOpenDisplay(NULL)))
+			die("slock: cannot open display\n");
+		font_names = XListFonts(dpy, "*", 10000 /* list 10000 fonts*/, &count_fonts);
+		for (i=0; i<count_fonts; i++) {
+			fprintf(stderr, "%s\n", *(font_names+i));
+		}
+		return 0;
 	default:
 		usage();
 	} ARGEND
@@ -347,6 +560,35 @@
 	if (setuid(duid) < 0)
 		die("slock: setuid: %s\n", strerror(errno));
 
+	/* Load picture */
+    Imlib_Load_Error err = IMLIB_LOAD_ERROR_NONE;
+        Imlib_Image buffer = imlib_load_image_with_error_return(background_image, &err);
+    if (!background_image || err) {
+        feh_print_load_error(background_image, err);
+    };
+	imlib_context_set_image(buffer);
+        int background_image_width = imlib_image_get_width();
+        int background_image_height = imlib_image_get_height();
+
+        /* Create an image to be rendered */
+	Screen *scr = ScreenOfDisplay(dpy, DefaultScreen(dpy));
+	image = imlib_create_image(scr->width, scr->height);
+        imlib_context_set_image(image);
+
+        /* Fill the image for every X monitor */
+        XRRMonitorInfo	*monitors;
+        int number_of_monitors;
+        monitors = XRRGetMonitors(dpy, RootWindow(dpy, XScreenNumberOfScreen(scr)), True, &number_of_monitors);
+
+        for (int i = 0; i < number_of_monitors; i++) {
+            imlib_blend_image_onto_image(buffer, 0, 0, 0, background_image_width, background_image_height, monitors[i].x, monitors[i].y, monitors[i].width, monitors[i].height);
+        }
+
+        /* Clean up */
+        imlib_context_set_image(buffer);
+        imlib_free_image();
+        imlib_context_set_image(image);
+
 	/* check for Xrandr support */
 	rr.active = XRRQueryExtension(dpy, &rr.evbase, &rr.errbase);
 
@@ -355,10 +597,12 @@
 	if (!(locks = calloc(nscreens, sizeof(struct lock *))))
 		die("slock: out of memory\n");
 	for (nlocks = 0, s = 0; s < nscreens; s++) {
-		if ((locks[s] = lockscreen(dpy, &rr, s)) != NULL)
+		if ((locks[s] = lockscreen(dpy, &rr, s)) != NULL) {
+			writemessage(dpy, locks[s]->win, s);
 			nlocks++;
-		else
+		} else {
 			break;
+		}
 	}
 	XSync(dpy, 0);
 
@@ -366,6 +610,20 @@
 	if (nlocks != nscreens)
 		return 1;
 
+	/* DPMS magic to disable the monitor */
+	if (!DPMSCapable(dpy))
+		die("slock: DPMSCapable failed\n");
+	if (!DPMSEnable(dpy))
+		die("slock: DPMSEnable failed\n");
+	if (!DPMSGetTimeouts(dpy, &standby, &suspend, &off))
+		die("slock: DPMSGetTimeouts failed\n");
+	if (!standby || !suspend || !off)
+		die("slock: at least one DPMS variable is zero\n");
+	if (!DPMSSetTimeouts(dpy, monitortime, monitortime, monitortime))
+		die("slock: DPMSSetTimeouts failed\n");
+
+	XSync(dpy, 0);
+
 	/* run post-lock command */
 	if (argc > 0) {
 		switch (fork()) {
@@ -383,5 +641,9 @@
 	/* everything is now blank. Wait for the correct password */
 	readpw(dpy, &rr, locks, nscreens, hash);
 
+	/* reset DPMS values to inital ones */
+	DPMSSetTimeouts(dpy, standby, suspend, off);
+	XSync(dpy, 0);
+
 	return 0;
 }
